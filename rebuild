#! /bin/sh
# NOTE: calling sudo inside a script is not best practice, but it works in this case

# Parse arguments
FULL_UPDATE=false
COMMIT_MSG=""
SYSTEM_ARG=""

while [ $# -gt 0 ]; do
  case "$1" in
    --full)
      FULL_UPDATE=true
      shift
      ;;
    *)
      if [ -z "$SYSTEM_ARG" ]; then
        SYSTEM_ARG="$1"
      else
        COMMIT_MSG="$1"
      fi
      shift
      ;;
  esac
done

# Get current hostname if not specified
if [ -z "$SYSTEM_ARG" ]; then
  SYSTEM_ARG=$(hostname)
fi

# Map hostnames to directory names
get_system_dir() {
  case "$1" in
    "nixt460") echo "t460" ;;
    "nixhq") echo "hq" ;;
    "nixt15g") echo "t15g" ;;
    *) echo "$1" ;;  # Default to the name itself
  esac
}

SYSTEM_DIR=$(get_system_dir "$SYSTEM_ARG")

echo "Rebuilding system $SYSTEM_ARG..."

# Only run full update tasks if --full flag is provided
if [ "$FULL_UPDATE" = true ]; then
  echo "Running full update (flatpak, nix channel, garbage collection)..."
  flatpak update -y
  sudo nix-channel --update
  sudo nix-env --delete-generations 60d
  sudo nix-collect-garbage --delete-older-than 60d
fi
sudo nixos-rebuild switch
retval=$?

if [ $retval -eq 0 ]; then
  echo "Build successful! Committing changes..."
  pushd /home/miscguy/coding/nixos
  git pull
  
  # Get current generation number
  gennbr="$(sudo nix-env --list-generations -p /nix/var/nix/profiles/system | grep current | awk '{print $1}')"
  
  # Use commit message if provided
  if [ -n "$COMMIT_MSG" ]; then
    msg="$SYSTEM_ARG: generation $gennbr - $COMMIT_MSG"
  else
    msg="$SYSTEM_ARG: generation $gennbr"
  fi
  
  # Selectively commit relevant files for this system
  git add flake.* ${SYSTEM_DIR}/* shared/* common/*
  git commit -m "$msg" 
  git push
  popd
  
  echo "Rebuild completed successfully!"
else
  echo "Build failed with error code $retval"
fi

# TODO: Future enhancements to consider:
# 1. Add a recovery mechanism that can roll back to previous generation if tests fail
#    - Create system-specific test scripts in each system directory
#    - After rebuild, run tests and roll back if they fail
#
# 2. Implement a lock file mechanism to prevent multiple concurrent rebuilds
#    - Create a lock file at the start of the script
#    - Check for existing lock file and exit if one exists
#    - Remove lock file on script completion or error
